import * as server from "@minecraft/server";

export class BeforePlayerSleepEvent {
    player: server.Player;
}

export class BeforePlayerSleepEventSignal implements EventSignal<BeforePlayerSleepEvent> {
    subscribe(callback: (arg: BeforePlayerSleepEvent) => void): (arg: BeforePlayerSleepEvent) => void;
    unsubscribe(callback: (arg: BeforePlayerSleepEvent) => void): void;
}

export class CommandType<T1 extends string, T2 extends any[][]> {
    #run: (...commands: TupleToUnion<T2>) => Promise<server.CommandResult>;
    id: T1;
    runAsync(...commands: TupleToUnion<T2>): Promise<server.CommandResult>;
    getPermissionLevel(): number;
    constructor(identifier: T1, run: (...commands: TupleToUnion<T2>) => Promise<server.CommandResult>);
}

interface Events {
    [eventName: string]: EventSignal<any> | undefined;
}

/**
 * @description A final integer type
 */
type int = number;

interface EventSignal<T> {
    subscribe(callback: (arg: T) => void): (arg: T) => void;
    unsubscribe(callback: (arg: T) => void): void;
}

export class EventSignal<T> implements EventSignal<T> {
    static from<T>(ventSignalLike: EventSignal<T>): EventSignal<T>
    subscribe(callback: (arg: T) => void): (arg: T) => void;
    unsubscribe(callback: (arg: T) => void): void;
}

export class MinecraftCommandTypes {
    weather: CommandType<"weather", [["clear" | "rain" | "thunder", int], ["query"]]>
}

export class World {
    events: Events & { [eventName in keyof server.Events]: server.Events[eventName]; };
}

export const world: World;

type TupleToUnion<T extends any[]> = T extends [infer F, ...infer rest] ? F | TupleToUnion<rest> : never[];
