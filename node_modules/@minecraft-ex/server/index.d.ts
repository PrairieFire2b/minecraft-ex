import * as server from "@minecraft/server";

export class BeforePlayerSelectedSlotEvent {
    cancel: boolean;
    currentSelectedSlot: number;
    selectedSlot: number;
    player: server.Player;
}

export class BeforePlayerSelectedEventSignal implements EventSignal<BeforePlayerSelectedSlotEvent> {
    subscribe(callback: (arg: BeforePlayerSelectedSlotEvent) => void): (arg: BeforePlayerSelectedSlotEvent) => void;
    unsubscribe(callback: (arg: BeforePlayerSelectedSlotEvent) => void): void;
}

export class BeforePlayerSleepEvent {
    cancel: boolean;
    player: server.Player;
}

export class BeforePlayerSleepEventSignal implements EventSignal<BeforePlayerSleepEvent> {
    subscribe(callback: (arg: BeforePlayerSleepEvent) => void): (arg: BeforePlayerSleepEvent) => void;
    unsubscribe(callback: (arg: BeforePlayerSleepEvent) => void): void;
}

interface CommandType<T1 extends string, T2 extends 0 | 1 | 2 | 3 | 4, T3 extends any[][]> {
    id: T1;
    run(executor: target, ...commands: TupleToUnion<T3>): Promise<server.CommandResult>;
    permissionLevel(): T2;
}

export class CommandType<T1 extends string, T2 extends 0 | 1 | 2 | 3 | 4, T3 extends any[][]> implements CommandType<T1, T2, T3> {
    id: T1;
    run(executor: target, ...commands: TupleToUnion<T3>): Promise<server.CommandResult>;
    permissionLevel(): T2;
}

/**
 * @description A final integer type
 */
type int = number;

interface EventSignal<T> {
    subscribe(callback: (arg: T) => void): (arg: T) => void;
    unsubscribe(callback: (arg: T) => void): void;
}

export class EventSignal<T> implements EventSignal<T> {
    static from<T>(ventSignalLike: EventSignal<T>): EventSignal<T>
    subscribe(callback: (arg: T) => void): (arg: T) => void;
    unsubscribe(callback: (arg: T) => void): void;
}

export class Location extends server.Location {
    from(vector: server.Vector3): server.Location;
}

declare global {
    interface ObjectConstructor {
        stringify(o: object): string;
    }
    var Object: ObjectConstructor;
}

export class MinecraftCommandTypes {
    static alwaysday: CommandType<"alwaysday", 1, [[boolean?]]>;
    static clear: CommandType<"clear", 1, [[target?, server.ItemType?, int?, int?]]>;
    static daylock: CommandType<"daylock", 1, [[boolean?]]>;
    static op: CommandType<"op", 2, [[target]]>;
    static say: CommandType<"say", 0, [[string?]]>;
    static tellraw: CommandType<"tellraw", 0, [[target, server.RawMessage]]>;
    static titleraw: CommandType<"titleraw", 1, [[target, TitleRawSet, server.RawMessage]]>;
    static weather: CommandType<"weather", 1, [["clear" | "rain" | "thunder", int?], ["query"]]>;
}

export class MinecraftEventTypes {
    /**
     * This event fires before a chat message is broadcast or
     * delivered. The event can be canceled, and the message can
     * also be updated.
     */
    readonly beforeChat: server.BeforeChatEventSignal;
    /**
     * This event is fired before the triggering of an entity event
     * that updates the component definition state of an entity.
     * Within this event, you can cancel or shape the impacted
     * components and event triggers.
     */
    readonly beforeDataDrivenEntityTriggerEvent: server.BeforeDataDrivenEntityTriggerEventSignal;
    /**
     * This event is fired before an explosion occurs.
     */
    readonly beforeExplosion: server.BeforeExplosionEventSignal;
    /**
     * For custom items, this event is triggered before the set of
     * defined components for the item change in response to a
     * triggered event. Note that this event is only fired for
     * custom data-driven items.
     */
    readonly beforeItemDefinitionEvent: server.BeforeItemDefinitionEventSignal;
    /**
     * This event fires before an item is used by an entity or
     * player.
     */
    readonly beforeItemUse: server.BeforeItemUseEventSignal;
    /**
     * This event fires before an item is used on a block by an
     * entity or player.
     */
    readonly beforeItemUseOn: server.BeforeItemUseOnEventSignal;
    /**
     * Fires before a piston is activated.
     */
    readonly beforePistonActivate: server.BeforePistonActivateEventSignal;
    readonly beforePlayerSelectedSlot: BeforePlayerSelectedEventSignal;
    readonly beforePlayerSleep: BeforePlayerSleepEventSignal;
    /**
     * This event fires for a block that is broken by a player.
     */
    readonly blockBreak: server.BlockBreakEventSignal;
    /**
     * This event fires for each BlockLocation destroyed by an
     * explosion. It is fired after the blocks have already been
     * destroyed.
     */
    readonly blockExplode: server.BlockExplodeEventSignal;
    /**
     * This event fires for a block that is placed by a player.
     */
    readonly blockPlace: server.BlockPlaceEventSignal;
    /**
     * This event fires when a button is pushed.
     */
    readonly buttonPush: server.ButtonPushEventSignal;
    /**
     * This event is triggered after a chat message has been
     * broadcast or sent to players.
     */
    readonly chat: server.ChatEventSignal;
    /**
     * This event is fired when an entity event has been triggered
     * that will update the component definition state of an
     * entity.
     */
    readonly dataDrivenEntityTriggerEvent: server.DataDrivenEntityTriggerEventSignal;
    /**
     * This event fires when an effect, like poisoning, is added to
     * an entity.
     */
    readonly effectAdd: server.EffectAddEventSignal;
    /**
     * This event fires when an entity hits (makes a melee attack)
     * and potentially impacts another entity or block.
     */
    readonly entityHit: server.EntityHitEventSignal;
    /**
     * This event fires when an entity is hurt (takes damage).
     */
    readonly entityHurt: server.EntityHurtEventSignal;
    /**
     * This event fires when an entity is spawned.
     */
    readonly entitySpawn: server.EntitySpawnEventSignal;
    /**
     * This event is fired after an explosion occurs.
     */
    readonly explosion: server.ExplosionEventSignal;
    /**
     * This event fires when a chargeable item completes charging.
     */
    readonly itemCompleteCharge: server.ItemCompleteChargeEventSignal;
    /**
     * For custom items, this event is triggered when the
     * fundamental set of defined components for the item change.
     * Note that this event is only fired for custom data-driven
     * items.
     */
    readonly itemDefinitionEvent: server.ItemDefinitionEventSignal;
    /**
     * This event fires when a chargeable item is released from
     * charging.
     */
    readonly itemReleaseCharge: server.ItemReleaseChargeEventSignal;
    /**
     * This event fires when a chargeable item starts charging.
     */
    readonly itemStartCharge: server.ItemStartChargeEventSignal;
    /**
     * This event fires when any particular item is starting to be
     * used by an entity or player.
     */
    readonly itemStartUseOn: server.ItemStartUseOnEventSignal;
    /**
     * This event fires when a chargeable item stops charging.
     */
    readonly itemStopCharge: server.ItemStopChargeEventSignal;
    /**
     * This event fires when any particular item is ending being
     * used by an entity or player.
     */
    readonly itemStopUseOn: server.ItemStopUseOnEventSignal;
    /**
     * This event fires when any particular item is used by an
     * entity or player.
     */
    readonly itemUse: server.ItemUseEventSignal;
    /**
     * This event fires when any particular item is used on a block
     * by an entity or player.
     */
    readonly itemUseOn: server.ItemUseOnEventSignal;
    /**
     * This event fires when a lever activates or is deactivated.
     */
    readonly leverActivate: server.LeverActionEventSignal;
    /**
     * This event is an internal implementation detail, and is
     * otherwise not currently functional.
     */
    readonly messageReceive: server.ServerMessageSignal;
    /**
     * This event fires when a piston expands or retracts.
     */
    readonly pistonActivate: server.PistonActivateEventSignal;
    /**
     * This event fires when a player joins a world.  See also
     * playerSpawn for another related event you can trap for when
     * a player is spawned the first time within a world.
     */
    readonly playerJoin: server.PlayerJoinEventSignal;
    /**
     * This event fires when a player leaves a world.
     */
    readonly playerLeave: server.PlayerLeaveEventSignal;
    /**
     * This event fires when a player spawns or respawns. Note that
     * an additional flag within this event will tell you whether
     * the player is spawning right after join vs. a respawn.
     */
    readonly playerSpawn: server.PlayerSpawnEventSignal;
    /**
     * This event fires when a projectile hits an entity or block.
     */
    projectileHit: server.ProjectileHitEventSignal;
    /**
     * This event fires every tick - which is 20 times per second.
     */
    readonly tick: server.TickEventSignal;
    /**
     * This event will be triggered when the weather changes within
     * Minecraft.
     */
    readonly weatherChange: server.WeatherChangeEventSignal;
    /**
     * This event fires when the script environment is initialized
     * on a World. In addition, you can register dynamic properties
     * within the scope of a world Initialize event.
     */
    readonly worldInitialize: server.WorldInitializeEventSignal;
}

export class World {
}

export type target = server.Entity | String | server.Player;

export type TitleRawSet = "actionbar" | "subtitle" | "title";

type TupleToUnion<T extends any[]> = T extends [infer F, ...infer rest] ? F | TupleToUnion<rest> : never[];
